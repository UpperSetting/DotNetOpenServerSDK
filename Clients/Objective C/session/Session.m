//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./com/us/openserver/session/Session.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/us/openserver/Client.h"
#include "com/us/openserver/Level.h"
#include "com/us/openserver/Logger.h"
#include "com/us/openserver/protocols/AuthenticationProtocolBase.h"
#include "com/us/openserver/protocols/BinaryReader.h"
#include "com/us/openserver/protocols/BinaryWriter.h"
#include "com/us/openserver/protocols/CapabilitiesProtocol.h"
#include "com/us/openserver/protocols/ProtocolBase.h"
#include "com/us/openserver/protocols/ProtocolConfiguration.h"
#include "com/us/openserver/protocols/SessionLayerProtocol.h"
#include "com/us/openserver/session/PacketHandler.h"
#include "com/us/openserver/session/PacketReadTypes.h"
#include "com/us/openserver/session/Session.h"
#include "com/us/openserver/session/SessionCloser.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/Exception.h"
#include "java/lang/Integer.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/Thread.h"
#include "java/net/Socket.h"
#include "java/util/Collection.h"
#include "java/util/HashMap.h"
#include "java/util/Set.h"

@interface ComUsOpenserverSessionSession () {
 @public
  jboolean isClosed_;
  ComUsOpenserverClient *client_;
  ComUsOpenserverProtocolsCapabilitiesProtocol *capabilitiesProtocol_;
  JavaUtilHashMap *protocolConfigurations_;
  JavaUtilHashMap *protocolImplementations_;
  ComUsOpenserverLogger *logger_;
  JavaIoInputStream *is_;
  id userData_;
  id syncObject_;
  JavaIoOutputStream *os_;
  NSString *address_;
  jint id__;
}

- (NSString *)toHexStringWithByteArray:(IOSByteArray *)val
                               withInt:(jint)position
                               withInt:(jint)length;

@end

J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, client_, ComUsOpenserverClient *)
J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, capabilitiesProtocol_, ComUsOpenserverProtocolsCapabilitiesProtocol *)
J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, protocolConfigurations_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, protocolImplementations_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, logger_, ComUsOpenserverLogger *)
J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, is_, JavaIoInputStream *)
J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, userData_, id)
J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, syncObject_, id)
J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, os_, JavaIoOutputStream *)
J2OBJC_FIELD_SETTER(ComUsOpenserverSessionSession, address_, NSString *)

static jint ComUsOpenserverSessionSession_sessionId_;
J2OBJC_STATIC_FIELD_GETTER(ComUsOpenserverSessionSession, sessionId_, jint)
J2OBJC_STATIC_FIELD_REF_GETTER(ComUsOpenserverSessionSession, sessionId_, jint)

__attribute__((unused)) static NSString *ComUsOpenserverSessionSession_toHexStringWithByteArray_withInt_withInt_(ComUsOpenserverSessionSession *self, IOSByteArray *val, jint position, jint length);

@implementation ComUsOpenserverSessionSession

- (instancetype)initWithComUsOpenserverClient:(ComUsOpenserverClient *)client
                            withJavaNetSocket:(JavaNetSocket *)socket
                                 withNSString:(NSString *)address {
  ComUsOpenserverSessionSession_initWithComUsOpenserverClient_withJavaNetSocket_withNSString_(self, client, socket, address);
  return self;
}

- (void)close {
  if (!isClosed_) {
    isClosed_ = YES;
    @synchronized(protocolImplementations_) {
      for (ComUsOpenserverProtocolsProtocolBase * __strong pl in nil_chk([((JavaUtilHashMap *) nil_chk(protocolImplementations_)) values])) [((ComUsOpenserverProtocolsProtocolBase *) nil_chk(pl)) close];
      [protocolImplementations_ clear];
    }
    @try {
      [((JavaIoInputStream *) nil_chk(is_)) close];
    }
    @catch (JavaIoIOException *ex) {
    }
    @try {
      [((JavaIoOutputStream *) nil_chk(os_)) close];
    }
    @catch (JavaIoIOException *ex) {
    }
  }
}

- (void)closeWithInt:(jint)protocolId {
  ComUsOpenserverProtocolsProtocolBase *p = nil;
  @synchronized(protocolImplementations_) {
    if ([((JavaUtilHashMap *) nil_chk(protocolImplementations_)) containsKeyWithId:JavaLangInteger_valueOfWithInt_(protocolId)]) {
      p = [protocolImplementations_ getWithId:JavaLangInteger_valueOfWithInt_(protocolId)];
      (void) [protocolImplementations_ removeWithId:JavaLangInteger_valueOfWithInt_(protocolId)];
    }
  }
  if (p != nil) [p close];
}

- (void)dispose {
  @synchronized(syncObject_) {
    if (!isClosed_) {
      isClosed_ = YES;
      @synchronized(protocolImplementations_) {
        for (ComUsOpenserverProtocolsProtocolBase * __strong pl in nil_chk([((JavaUtilHashMap *) nil_chk(protocolImplementations_)) values])) [((ComUsOpenserverProtocolsProtocolBase *) nil_chk(pl)) dispose];
        [protocolImplementations_ clear];
      }
      @try {
        [((JavaIoInputStream *) nil_chk(is_)) close];
      }
      @catch (JavaIoIOException *ex) {
      }
      @try {
        [((JavaIoOutputStream *) nil_chk(os_)) close];
      }
      @catch (JavaIoIOException *ex) {
      }
    }
  }
}

- (void)beginRead {
  [new_JavaLangThread_initWithJavaLangRunnable_withNSString_(self, @"SessionThread") start];
}

- (void)connectionLostWithJavaLangException:(JavaLangException *)ex {
  jboolean tmp;
  @synchronized(syncObject_) {
    tmp = isClosed_;
    if (!isClosed_) {
      [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Critical() withNSString:NSString_formatWithNSString_withNSObjectArray_(@"The socket connection has been lost.  %1$s", [IOSObjectArray newArrayWithObjects:(id[]){ [((JavaLangException *) nil_chk(ex)) getMessage] } count:1 type:NSObject_class_()])];
      [self dispose];
    }
  }
  if (!tmp) [((ComUsOpenserverClient *) nil_chk(client_)) onConnectionLostWithJavaLangException:ex];
}

- (IOSIntArray *)getRemoteSupportedProtocolIds {
  return [((ComUsOpenserverProtocolsCapabilitiesProtocol *) nil_chk(capabilitiesProtocol_)) getRemoteSupportedProtocolIds];
}

- (IOSIntArray *)getLocalSupportedProtocolIds {
  IOSIntArray *protocolIds = [IOSIntArray newArrayWithLength:[((JavaUtilHashMap *) nil_chk(protocolConfigurations_)) size]];
  jint i = 0;
  for (JavaLangInteger *boxed__ in nil_chk([protocolConfigurations_ keySet])) {
    jint protcolId = [((JavaLangInteger *) nil_chk(boxed__)) intValue];
    *IOSIntArray_GetRef(protocolIds, i++) = protcolId;
  }
  return protocolIds;
}

- (void)onCapabilitiesErrorWithInt:(jint)protocolId
                      withNSString:(NSString *)message {
  ComUsOpenserverProtocolsProtocolBase *p = nil;
  @synchronized(protocolImplementations_) {
    if ([((JavaUtilHashMap *) nil_chk(protocolImplementations_)) containsKeyWithId:JavaLangInteger_valueOfWithInt_(protocolId)]) p = [protocolImplementations_ getWithId:JavaLangInteger_valueOfWithInt_(protocolId)];
  }
  if (p != nil) [p onErrorReceivedWithNSString:message];
}

- (NSString *)getAddress {
  return address_;
}

- (ComUsOpenserverProtocolsProtocolBase *)initialize__WithInt:(jint)protocolId
                                                       withId:(id)userData {
  ComUsOpenserverProtocolsProtocolBase *p = nil;
  @synchronized(protocolImplementations_) {
    if (![((JavaUtilHashMap *) nil_chk(protocolImplementations_)) containsKeyWithId:JavaLangInteger_valueOfWithInt_(protocolId)]) {
      if (![((JavaUtilHashMap *) nil_chk(protocolConfigurations_)) containsKeyWithId:JavaLangInteger_valueOfWithInt_(protocolId)]) @throw new_JavaLangException_initWithNSString_(@"Invalid or unsupported protocol.");
      ComUsOpenserverProtocolsProtocolConfiguration *pc = [protocolConfigurations_ getWithId:JavaLangInteger_valueOfWithInt_(protocolId)];
      IOSClass *cls = IOSClass_forName_([((ComUsOpenserverProtocolsProtocolConfiguration *) nil_chk(pc)) getClassPath]);
      p = (ComUsOpenserverProtocolsProtocolBase *) check_class_cast([((IOSClass *) nil_chk(cls)) newInstance], [ComUsOpenserverProtocolsProtocolBase class]);
      (void) [protocolImplementations_ putWithId:JavaLangInteger_valueOfWithInt_(protocolId) withId:p];
      [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Debug() withNSString:NSString_formatWithNSString_withNSObjectArray_(@"Initializing protocol %1$s...", [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(protocolId) } count:1 type:NSObject_class_()])];
      [((ComUsOpenserverProtocolsProtocolBase *) nil_chk(p)) initialize__WithComUsOpenserverSessionSession:self withComUsOpenserverProtocolsProtocolConfiguration:pc withId:userData];
    }
    else p = [protocolImplementations_ getWithId:JavaLangInteger_valueOfWithInt_(protocolId)];
  }
  return p;
}

- (void)onPacketReceivedWithComUsOpenserverProtocolsBinaryReader:(ComUsOpenserverProtocolsBinaryReader *)br {
  jint protocolId = [((ComUsOpenserverProtocolsBinaryReader *) nil_chk(br)) readUInt16];
  if (protocolId == 0) {
    [((ComUsOpenserverProtocolsCapabilitiesProtocol *) nil_chk(capabilitiesProtocol_)) onPacketReceivedWithComUsOpenserverProtocolsBinaryReader:br];
    return;
  }
  ComUsOpenserverProtocolsProtocolBase *p;
  @synchronized(protocolImplementations_) {
    if ([((JavaUtilHashMap *) nil_chk(protocolImplementations_)) containsKeyWithId:JavaLangInteger_valueOfWithInt_(protocolId)]) p = [protocolImplementations_ getWithId:JavaLangInteger_valueOfWithInt_(protocolId)];
    else {
      if (![((JavaUtilHashMap *) nil_chk(protocolConfigurations_)) containsKeyWithId:JavaLangInteger_valueOfWithInt_(protocolId)]) @throw new_JavaLangException_initWithNSString_(@"Invalid or unsupported protocol.");
      ComUsOpenserverProtocolsProtocolConfiguration *pc = [protocolConfigurations_ getWithId:JavaLangInteger_valueOfWithInt_(protocolId)];
      IOSClass *cls = IOSClass_forName_([((ComUsOpenserverProtocolsProtocolConfiguration *) nil_chk(pc)) getClassPath]);
      p = (ComUsOpenserverProtocolsProtocolBase *) check_class_cast([((IOSClass *) nil_chk(cls)) newInstance], [ComUsOpenserverProtocolsProtocolBase class]);
      if (p == nil) @throw new_JavaLangException_initWithNSString_(JreStrcat("$$", @"Unable to create protocol layer.  Class not found.  Class: ", [pc getClassPath]));
      if (!IsAuthenticated_ && !([p isKindOfClass:[ComUsOpenserverProtocolsAuthenticationProtocolBase class]])) @throw new_JavaLangException_initWithNSString_(JreStrcat("$$", @"Unable to add protocol layer.  Access Denied.  Class: ", [pc getClassPath]));
      (void) [protocolImplementations_ putWithId:JavaLangInteger_valueOfWithInt_(protocolId) withId:p];
      [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Debug() withNSString:JreStrcat("$I$", @"Initializing protocol ", protocolId, @"...")];
      [((ComUsOpenserverProtocolsProtocolBase *) nil_chk(p)) initialize__WithComUsOpenserverSessionSession:self withComUsOpenserverProtocolsProtocolConfiguration:pc withId:userData_];
    }
  }
  [((ComUsOpenserverProtocolsProtocolBase *) nil_chk(p)) onPacketReceivedWithComUsOpenserverProtocolsBinaryReader:br];
}

- (void)run {
  jint available = 0;
  @try {
    jbyte readState = ComUsOpenserverSessionPacketReadTypes_Header;
    IOSByteArray *buffer = [IOSByteArray newArrayWithLength:8192];
    JavaIoByteArrayOutputStream *packet = new_JavaIoByteArrayOutputStream_init();
    jint payloadLength = 0;
    jint payloadPosition = 0;
    jint position;
    while ((available = [((JavaIoInputStream *) nil_chk(is_)) readWithByteArray:buffer]) != -1) {
      position = 0;
      while (available > 0) {
        jint lengthToRead;
        if (readState == ComUsOpenserverSessionPacketReadTypes_Header) {
          lengthToRead = [packet size] + available >= ComUsOpenserverProtocolsSessionLayerProtocol_HEADER_LENGTH ? ComUsOpenserverProtocolsSessionLayerProtocol_HEADER_LENGTH - [packet size] : available;
          [packet writeWithByteArray:buffer withInt:position withInt:lengthToRead];
          position += lengthToRead;
          available -= lengthToRead;
          if ([packet size] >= ComUsOpenserverProtocolsSessionLayerProtocol_HEADER_LENGTH) readState = ComUsOpenserverSessionPacketReadTypes_HeaderComplete;
        }
        if (readState == ComUsOpenserverSessionPacketReadTypes_HeaderComplete) {
          ComUsOpenserverProtocolsBinaryReader *br = new_ComUsOpenserverProtocolsBinaryReader_initWithByteArray_([packet toByteArray]);
          @try {
            jint protocolId = [br readUInt16];
            if (protocolId != ComUsOpenserverProtocolsSessionLayerProtocol_PROTOCAL_IDENTIFIER) @throw new_JavaLangException_initWithNSString_(@"Invalid or unsupported protocol.");
            payloadLength = [br readInt32];
          }
          @finally {
            @try {
              [br close];
            }
            @catch (JavaIoIOException *ex) {
            }
          }
          readState = ComUsOpenserverSessionPacketReadTypes_Payload;
        }
        if (readState == ComUsOpenserverSessionPacketReadTypes_Payload) {
          lengthToRead = available >= payloadLength - payloadPosition ? payloadLength - payloadPosition : available;
          [packet writeWithByteArray:buffer withInt:position withInt:lengthToRead];
          position += lengthToRead;
          available -= lengthToRead;
          payloadPosition += lengthToRead;
          if ([packet size] >= ComUsOpenserverProtocolsSessionLayerProtocol_HEADER_LENGTH + payloadLength) {
            if ([((ComUsOpenserverLogger *) nil_chk(logger_)) getLogPackets]) [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Debug() withNSString:JreStrcat("$$", @"RECV: ", ComUsOpenserverSessionSession_toHexStringWithByteArray_withInt_withInt_(self, [packet toByteArray], 0, [packet size]))];
            ComUsOpenserverProtocolsBinaryReader *br = new_ComUsOpenserverProtocolsBinaryReader_initWithByteArray_([packet toByteArray]);
            [br skipWithLong:ComUsOpenserverProtocolsSessionLayerProtocol_HEADER_LENGTH];
            ComUsOpenserverSessionPacketHandler *packetHandler = new_ComUsOpenserverSessionPacketHandler_initWithComUsOpenserverSessionSession_withComUsOpenserverProtocolsBinaryReader_(self, br);
            [packetHandler execute];
            readState = ComUsOpenserverSessionPacketReadTypes_Header;
            packet = new_JavaIoByteArrayOutputStream_init();
            payloadLength = 0;
            payloadPosition = 0;
          }
        }
      }
    }
  }
  @catch (JavaLangException *ex) {
    [self connectionLostWithJavaLangException:ex];
  }
}

- (void)sendWithByteArray:(IOSByteArray *)buf {
  ComUsOpenserverProtocolsBinaryWriter *bw = new_ComUsOpenserverProtocolsBinaryWriter_init();
  @try {
    [bw writeUInt16WithInt:ComUsOpenserverProtocolsSessionLayerProtocol_PROTOCAL_IDENTIFIER];
    [bw writeUIntWithInt:((IOSByteArray *) nil_chk(buf))->size_];
    [bw writeWithByteArray:buf];
    buf = [bw toByteArray];
    if ([((ComUsOpenserverLogger *) nil_chk(logger_)) getLogPackets]) [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Debug() withNSString:JreStrcat("$$", @"SEND: ", ComUsOpenserverSessionSession_toHexStringWithByteArray_withInt_withInt_(self, buf, 0, ((IOSByteArray *) nil_chk(buf))->size_))];
    @synchronized(os_) {
      [bw writeToWithJavaIoOutputStream:os_];
    }
  }
  @finally {
    @try {
      [bw close];
    }
    @catch (JavaIoIOException *ex) {
    }
  }
}

- (void)signalClose {
  ComUsOpenserverSessionSessionCloser *closer = new_ComUsOpenserverSessionSessionCloser_initWithComUsOpenserverSessionSession_(self);
  [closer close];
}

- (NSString *)toHexStringWithByteArray:(IOSByteArray *)val
                               withInt:(jint)position
                               withInt:(jint)length {
  return ComUsOpenserverSessionSession_toHexStringWithByteArray_withInt_withInt_(self, val, position, length);
}

- (void)logWithComUsOpenserverLevelEnum:(ComUsOpenserverLevelEnum *)level
                           withNSString:(NSString *)message {
  [((ComUsOpenserverLogger *) nil_chk(logger_)) logWithComUsOpenserverLevelEnum:level withNSString:NSString_formatWithNSString_withNSObjectArray_(@"Session [%1$s %2$s] - %3$s", [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(id__), address_, message } count:3 type:NSObject_class_()])];
}

- (void)logWithJavaLangException:(JavaLangException *)ex {
  [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Error() withNSString:[((JavaLangException *) nil_chk(ex)) getMessage]];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithComUsOpenserverClient:withJavaNetSocket:withNSString:", "Session", NULL, 0x1, "Ljava.io.IOException;", NULL },
    { "close", NULL, "V", 0x1, NULL, NULL },
    { "closeWithInt:", "close", "V", 0x1, NULL, NULL },
    { "dispose", NULL, "V", 0x1, NULL, NULL },
    { "beginRead", NULL, "V", 0x1, NULL, NULL },
    { "connectionLostWithJavaLangException:", "connectionLost", "V", 0x1, NULL, NULL },
    { "getRemoteSupportedProtocolIds", NULL, "[I", 0x1, NULL, NULL },
    { "getLocalSupportedProtocolIds", NULL, "[I", 0x1, NULL, NULL },
    { "onCapabilitiesErrorWithInt:withNSString:", "onCapabilitiesError", "V", 0x1, NULL, NULL },
    { "getAddress", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "initialize__WithInt:withId:", "initialize", "Lcom.us.openserver.protocols.ProtocolBase;", 0x1, "Ljava.lang.Exception;", NULL },
    { "onPacketReceivedWithComUsOpenserverProtocolsBinaryReader:", "onPacketReceived", "V", 0x1, "Ljava.lang.Exception;", NULL },
    { "run", NULL, "V", 0x1, NULL, NULL },
    { "sendWithByteArray:", "send", "V", 0x1, "Ljava.io.IOException;", NULL },
    { "signalClose", NULL, "V", 0x1, NULL, NULL },
    { "toHexStringWithByteArray:withInt:withInt:", "toHexString", "Ljava.lang.String;", 0x2, NULL, NULL },
    { "logWithComUsOpenserverLevelEnum:withNSString:", "log", "V", 0x1, NULL, NULL },
    { "logWithJavaLangException:", "log", "V", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "IsAuthenticated_", NULL, 0x1, "Z", NULL, NULL,  },
    { "UserName_", NULL, 0x1, "Ljava.lang.String;", NULL, NULL,  },
    { "isClosed_", NULL, 0x2, "Z", NULL, NULL,  },
    { "client_", NULL, 0x2, "Lcom.us.openserver.Client;", NULL, NULL,  },
    { "capabilitiesProtocol_", NULL, 0x2, "Lcom.us.openserver.protocols.CapabilitiesProtocol;", NULL, NULL,  },
    { "protocolConfigurations_", NULL, 0x2, "Ljava.util.HashMap;", NULL, "Ljava/util/HashMap<Ljava/lang/Integer;Lcom/us/openserver/protocols/ProtocolConfiguration;>;",  },
    { "protocolImplementations_", NULL, 0x2, "Ljava.util.HashMap;", NULL, "Ljava/util/HashMap<Ljava/lang/Integer;Lcom/us/openserver/protocols/ProtocolBase;>;",  },
    { "logger_", NULL, 0x2, "Lcom.us.openserver.Logger;", NULL, NULL,  },
    { "is_", NULL, 0x2, "Ljava.io.InputStream;", NULL, NULL,  },
    { "userData_", NULL, 0x2, "Ljava.lang.Object;", NULL, NULL,  },
    { "syncObject_", NULL, 0x2, "Ljava.lang.Object;", NULL, NULL,  },
    { "os_", NULL, 0x2, "Ljava.io.OutputStream;", NULL, NULL,  },
    { "address_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "id__", "id", 0x2, "I", NULL, NULL,  },
    { "sessionId_", NULL, 0xa, "I", &ComUsOpenserverSessionSession_sessionId_, NULL,  },
  };
  static const J2ObjcClassInfo _ComUsOpenserverSessionSession = { 2, "Session", "com.us.openserver.session", NULL, 0x1, 18, methods, 15, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_ComUsOpenserverSessionSession;
}

@end

void ComUsOpenserverSessionSession_initWithComUsOpenserverClient_withJavaNetSocket_withNSString_(ComUsOpenserverSessionSession *self, ComUsOpenserverClient *client, JavaNetSocket *socket, NSString *address) {
  (void) NSObject_init(self);
  self->protocolImplementations_ = new_JavaUtilHashMap_init();
  self->syncObject_ = new_NSObject_init();
  self->client_ = client;
  self->capabilitiesProtocol_ = new_ComUsOpenserverProtocolsCapabilitiesProtocol_initWithComUsOpenserverSessionSession_(self);
  self->protocolConfigurations_ = [((ComUsOpenserverClient *) nil_chk(client)) getProtocolConfigurations];
  self->logger_ = [client getLogger];
  self->userData_ = [client getUserData];
  self->is_ = [((JavaNetSocket *) nil_chk(socket)) getInputStream];
  self->os_ = [socket getOutputStream];
  self->address_ = address;
  self->id__ = ++ComUsOpenserverSessionSession_sessionId_;
}

ComUsOpenserverSessionSession *new_ComUsOpenserverSessionSession_initWithComUsOpenserverClient_withJavaNetSocket_withNSString_(ComUsOpenserverClient *client, JavaNetSocket *socket, NSString *address) {
  ComUsOpenserverSessionSession *self = [ComUsOpenserverSessionSession alloc];
  ComUsOpenserverSessionSession_initWithComUsOpenserverClient_withJavaNetSocket_withNSString_(self, client, socket, address);
  return self;
}

NSString *ComUsOpenserverSessionSession_toHexStringWithByteArray_withInt_withInt_(ComUsOpenserverSessionSession *self, IOSByteArray *val, jint position, jint length) {
  if (val == nil || val->size_ == 0) return @"";
  JavaLangStringBuilder *s = new_JavaLangStringBuilder_initWithInt_(((IOSByteArray *) nil_chk(val))->size_ * 2);
  for (jint i = position; i < position + length; i++) {
    NSString *str = JavaLangInteger_toHexStringWithInt_((jint) IOSByteArray_Get(val, i) & (jint) 0x000000FF);
    if (((jint) IOSByteArray_Get(val, i) & (jint) 0x000000FF) <= 15) str = JreStrcat("C$", '0', str);
    if (i > position) str = JreStrcat("C$", ' ', str);
    (void) [s appendWithNSString:str];
  }
  return [((NSString *) nil_chk([s description])) uppercaseString];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComUsOpenserverSessionSession)
